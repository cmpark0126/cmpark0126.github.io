---
title:  "운영체제(2) - 시스템 구조(2)"
modified: 2019-05-12T12:00:00-:30:00
categories:
  - Operating_System
tags:
  - [CS, Operating_System]
---

'운영체제'를 공부하여 정리한 내용입니다.

## 5. System Program

### 컴퓨터 시스템 계층 구조

-   다음과 같은 계층을 가진다.
    -   &lt;최하위> :
    -   하드웨어
    -   OS
    -   System Program
    -   Application Program
    -   : &lt;최상위>

### System Program

-   System utility로도 알려져 있다.
-   프로그램 개발과 실행을 위해 보다 편리한 환경을 제공 (with Syscall)

    -   파일 관리
    -   상태 정보
        -   htop 등 (Linux program)
    -   파일 변경
        -   vi/vim 등 (Linux program)
    -   프로그래밍 언어 지원
        -   컴파일러
        -   어셈블러
        -   인터프리터
    -   프로그램의 적재와 실행
        -   로더
    -   통신
        -   FTP, SSH 등

-   대부분의 사용자는 System call을 바로 사용하기보다 위의 System program을 주로 사용하게 된다.
    -   그래서 사용자가 유용하다고 결정하는 경험적 기준은, OS가 제공하는 System program의 구성이 된다.

## 6. 운영체제 설계 및 구현

### Design Goals(설계 목표)

-   이는 요구 조건을 사용자로 맞추는지 시스템에 맞추는지에 따라서 달라진다.
-   그래서 정확히 정해진 것은 없지만 , 일부 원칙은 존재한다.
-   (추후 업데이트)

## 7. OS 구조

### 접근 방식

-   기본적으로 현대의 OS는 크고 복잡하다.
-   하지만 동시에 적절히 동작하고, 쉽게 변경될 수 있어야 한다.
-   그렇기에 일반적으로 하나의 커다란 프로그램을 만들기 보다는 모듈화하여 프로그램을 작성하고 이를 결합하여 하나의 커널로 만드는 접근을 한다.

### 간단한 구조

-   MS-DOS, UNIX 초기 버전
-   (추후 업데이트)

### Layered Approach(계층적 접근)

-   위에서 보였던 컴퓨터 시스템 계층 구조의 기반이 되는 접근 방법이라고 할 수 있겠다.
-   조금 더 명확히 보자면, 하드웨어를 Base로 하고 맨 윗층은 항상 사용자 인터페이스가 되는 형태를 가진다.
-   다만, 그 사이에는 설계를 하는 사람이 적절하게 계층을 정의하고 구현해야 한다.
-   주의할 점은 다음과 같다.
    -   각 계층의 작업은 인터페이스를 제외하고 다른 방식으로는 다른 층과 커뮤니케이션 할 수 없다.
    -   인터페이스는 인접한 층에서만 사용 가능하다.
    -   하위 층의 정보는 상위 계층에서는 볼 수 없어야 하며, 상위 계층에서는 하위 계층이 잘 동작한다는 가정하에 동작이 정의된다.
    -   위의 주의점을 위해서 설계자는 하나의 계층을 정의할 때 매우 신중히 정의해야 한다.
-   이점은 다음과 같다.
    -   특정 문제가 생기면 관련한 계층만 보면 되기 때문에 디버깅이 이전보다는 쉽다.
    -   하위 계층이 올바로 일을 한다는 가정에서, User가 프로그램을 만들 때는 공시된 서비스를 이용해서 자유롭게 자신이 원하는 시스템을 구성하는 것이 가능하다.
-   단점은 다음과 같다.
    -   결과적으로 하드웨어의 지원을 받는 프로그램을 실행시키기 위해서는 매번 최상위 층에서 하드웨어 지원을 요청하기 까지 필요없어보이는 계층을 지나쳐와야 한다.
    -   이는 전체 프로그램의 퍼포먼스를 낮추는 결과로 이어지기도 한다.
    -   아직은 이 단점을 해결할 수 있을만한 계층 구조는 등장하지 않았다.

### Microkernels

-   커널을 모듈화한 형태이다.
-   위에서 설명한 계층적 접근과의 차이점을 얘기해보자
    -   계층적 구조는 시스템 자체가 계층을 가져서 시스템 프로그램들 사이에서도 계층이 존재했었다.
    -   이 마이크로 커널의 경우는 각각 따로 구현된 프로그램을 커널에 붙이면 커널이 통신 설비를 제공하게 된다. 그리고 이는 결과적으로 필요한 모든 서비스들이 이 커널이 제공한 통신 설비를 따라서 요청이 필요한 프로그램에게 요청하여 응답을 받을 수 있도록 한다. 이를 통해 사용자는 최종적으로 원하는 결과를 얻을 수 있게된다.
-   장점을 말해보자.

    -   확장이 매우 용이하다. 모두 통신설비로 통신하여 전체 프로그램이 이루어진다고 생각하면, 아주 일관성있고 새로운 모듈이 추가되었을 때는 통신 설비만 새로 할당해 주면 된다는 것을 알 수 있다.
    -   통신만 커널을 통해서 이루어지게 되고, 나머지 작업은 각각의 프로그램(User mode)에서 이루어지기 때문에 신뢰성을 유지할 수 있게 된다. 유저 모드에서는 프로그램에서 문제가 생겨도 커널에는 어떠한 영향을 미칠 수 없다는 것을 보장할 수 있게 되기 때문이다.
    -   헷갈리지 말아야 할 점은, 최소한의 프로세스와 메모리 관리는 여전히 커널이 해주고 있으니 이 부분을 User mode에서 실행하는 것인가 하고 착각하지 말기 바란다.

-   단점을 말해보자?
    -   통신을 하는데 들어가는 비용은 생각보다 크다. 이 때문에 성능이 감소된다.
    -   그 때문에 주로 몇개의 계층은 다시 커널에서 실행하도록 옮겨가기도 했다.

### Module

-   이게 정말 대박이다.
-   위에서 논의한 마이크로 커널과 계층적 구조의 단점을 최소화하고, 계층적 구조의 장점을 최대한 가져간다.
-   우선 이는 객체지향 프로그래밍 기법을 사용한다.
    -   지금부터는 당신이 객체지향에서 자주 사용하는 Abstract class와 상속에 대한 개념을 알고 있다고 설명하겠다.
    -   우선 사용자는 커널에게 기본적으로 바라는 기능이 있다.
        -   하드웨어와의 커뮤니케이션
        -   다른 모듈과의 통신
    -   그리고 그러면서 커널에게 특수하게 바라는 기능이 있다(상황에 따라서): 이는 모듈이다.
        -   프로세스 스케쥴링
        -   파일 시스템
        -   적재가능 System call
        -   실행 파일 형식
        -   STREAMS
        -   장치 및 버스 드라이버
        -   기타
    -   기본적으로 바라는 기능은 핵심 커널 클래스로 구현되고, 나머지는 핵심 커널 클래스를 상속받아 이루어지는 모듈이된다.
    -   이 때 사용자는 필요에 따라 필요한 모듈을 사용하게되고, 이는 쓸모없는 기능을 제외하고 딱 필요한 기능만을 사용자에게 제공한다.; 계층화 구조에서 기능을 제공하는 점에서의 장점을 가지면서, 상위 계층에서 하위 계층으로 가면서 사용했던 쓸모없는 기능 호출이 생겼던 오버헤드를 줄이는 추가적인 이점을 얻는다.
    -   그리고 모듈끼리의 통신도 훨씬 자유로운데, 그 이유는 모든 프로그램이 동일한 부모 클래스인 커널을 통해 서비스를 사용하기 때문에, 굳이 유저 레벨에서의 메세지를 만들어서 커널을 통해 통신할 필요 없이, 각자가 핵심 커널에서 정의된 방식으로 통신하면 된다.; 이로 인해 메세지 통신으로 생기는 오버헤드가 사라지고, 퍼포먼스가 증가하게 된다.

### 현대의 OS

-   현대의 OS는 주로 마이크로 커널과 모듈화 커널을 섞어서 사용한다.

## 8. 가상 기계, 9. OS 디버깅, 10. OS 생성

-   (추후 업데이트)

## 11. System boot

-   다음의 순서를 알고 있으면 된다.
    -   컴퓨터가 켜지거나 리부트되면, 미리 지정된 메모리 위치로가서 부트로더를 실행시킨다. (주로 수정이 잘 안되는 EPROM에 저장된 프로그램이 부트로더이다. ROM은 주로 펌웨어라고 불린다.)
    -   EPROM에서 부트로더를 실행시키면 디스크에서 약속된 위치(주로 하드디스크의 0번째 블록)에서 부트 프로그램을 메인 메모리로 적재한다.
    -   적재된 부트 프로그램은 시스템에서 사용하는 웬만한 모든 값을 초기화하고, 디스크에서 커널을 찾아서 메인 메모리로 적재한다. 이 때 디스크의 어디에 커널이 있는지는 부트 프로그램이 미리 알고 있어야 한다.
    -   이제 OS가 돌아가기 시작했고, OS는 이벤트를 기다린다.
