---
title:  "운영체제(2) - 시스템 구조(2)"
modified: 2019-05-12T12:00:00-:30:00
categories:
  - Operating_System
tags:
  - [CS, Operating_System]
---

'운영체제'를 공부하여 정리한 내용입니다.

## 5. System Program

#### 컴퓨터 시스템 계층 구조

-   다음과 같은 계층을 가진다.
    -   &lt;최하위> :
    -   하드웨어
    -   OS
    -   System Program
    -   Application Program
    -   : &lt;최상위>

#### System Program

-   System utility로도 알려져 있다.
-   프로그램 개발과 실행을 위해 보다 편리한 환경을 제공 (with Syscall)

    -   파일 관리
    -   상태 정보
        -   htop 등 (Linux program)
    -   파일 변경
        -   vi/vim 등 (Linux program)
    -   프로그래밍 언어 지원
        -   컴파일러
        -   어셈블러
        -   인터프리터
    -   프로그램의 적재와 실행
        -   로더
    -   통신
        -   FTP, SSH 등

-   대부분의 사용자는 System call을 바로 사용하기보다 위의 System program을 주로 사용하게 된다.
    -   그래서 사용자가 유용하다고 결정하는 경험적 기준은, OS가 제공하는 System program의 구성이 된다.

## 6. 운영체제 설계 및 구현

#### Design Goals(설계 목표)

-   이는 요구 조건을 사용자로 맞추는지 시스템에 맞추는지에 따라서 달라진다.
-   그래서 정확히 정해진 것은 없지만 , 일부 원칙은 존재한다.
-   (추후 업데이트)

## 7. OS 구조

#### 접근 방식

-   기본적으로 현대의 OS는 크고 복잡하다.
-   하지만 동시에 적절히 동작하고, 쉽게 변경될 수 있어야 한다.
-   그렇기에 일반적으로 하나의 커다란 프로그램을 만들기 보다는 모듈화하여 프로그램을 작성하고 이를 결합하여 하나의 커널로 만드는 접근을 한다.

#### 간단한 구조

-   MS-DOS, UNIX 초기 버전
-   (추후 업데이트)

#### Layered Approach(계층적 접근)

-   위에서 보였던 컴퓨터 시스템 계층 구조의 기반이 되는 접근 방법이라고 할 수 있겠다.
-   조금 더 명확히 보자면, 하드웨어를 Base로 하고 맨 윗층은 항상 사용자 인터페이스가 되는 형태를 가진다.
-   다만, 그 사이에는 설계를 하는 사람이 적절하게 계층을 정의하고 구현해야 한다.
-   주의할 점은 다음과 같다.
    -   각 계층의 작업은 인터페이스를 제외하고 다른 방식으로는 다른 층과 커뮤니케이션 할 수 없다.
    -   인터페이스는 인접한 층에서만 사용 가능하다.
    -   하위 층의 정보는 상위 계층에서는 볼 수 없어야 하며, 상위 계층에서는 하위 계층이 잘 동작한다는 가정하에 동작이 정의된다.
    -   위의 주의점을 위해서 설계자는 하나의 계층을 정의할 때 매우 신중히 정의해야 한다.
-   이점은 다음과 같다.
    -   특정 문제가 생기면 관련한 계층만 보면 되기 때문에 디버깅이 이전보다는 쉽다.
    -   하위 계층이 올바로 일을 한다는 가정에서, User가 프로그램을 만들 때는 공시된 서비스를 이용해서 자유롭게 자신이 원하는 시스템을 구성하는 것이 가능하다.
-   단점은 다음과 같다.
    -   결과적으로 하드웨어의 지원을 받는 프로그램을 실행시키기 위해서는 매번 최상위 층에서 하드웨어 지원을 요청하기 까지 필요없어보이는 계층을 지나쳐와야 한다.
    -   이는 전체 프로그램의 퍼포먼스를 낮추는 결과로 이어지기도 한다.
    -   아직은 이 단점을 해결할 수 있을만한 계층 구조는 등장하지 않았다.

#### Microkernels

-   커널을 모듈화한 형태이다.
-   위에서 설명한 계층적 접근과의 차이점을 얘기해보자
    -   계층적 구조는 시스템 자체가 계층을 가져서 시스템 프로그램들 사이에서도 계층이 존재했었다.
    -   이 마이크로 커널의 경우는 각각 따로 구현된 프로그램을 커널에 붙이면 커널이 통신 설비를 제공하게 된다. 그리고 이는 결과적으로 필요한 모든 서비스들이 이 커널이 제공한 통신 설비를 따라서 요청이 필요한 프로그램에게 요청하여 응답을 받을 수 있도록 한다. 이를 통해 사용자는 최종적으로 원하는 결과를 얻을 수 있게된다.
-   장점을 말해보자.

    -   확장이 매우 용이하다. 모두 통신설비로 통신하여 전체 프로그램이 이루어진다고 생각하면, 아주 일관성있고 새로운 모듈이 추가되었을 때는 통신 설비만 새로 할당해 주면 된다는 것을 알 수 있다.
    -   통신만 커널을 통해서 이루어지게 되고, 나머지 작업은 각각의 프로그램(User mode)에서 이루어지기 때문에 신뢰성을 유지할 수 있게 된다. 유저 모드에서는 프로그램에서 문제가 생겨도 커널에는 어떠한 영향을 미칠 수 없다는 것을 보장할 수 있게 되기 때문이다.
    -   헷갈리지 말아야 할 점은, 최소한의 프로세스와 메모리 관리는 여전히 커널이 해주고 있으니 이 부분을 User mode에서 실행하는 것인가 하고 착각하지 말기 바란다.

-   단점을 말해보자?
    -   통신을 하는데 들어가는 비용은 생각보다 크다. 이 때문에 성능이 감소된다.
    -   그 때문에 주로 몇개의 계층은 다시 커널에서 실행하도록 옮겨가기도 했다.
