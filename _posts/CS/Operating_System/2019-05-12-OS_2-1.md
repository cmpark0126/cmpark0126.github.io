---
title:  "운영체제(2) - 시스템 구조(1)"
modified: 2019-05-12T12:00:00-:30:00
categories:
  - Operating_System
tags:
  - [CS, Operating_System]
---

'운영체제'를 공부하여 정리한 내용입니다.

## 1. 운영체제 서비스

### 구성 요소

-   메인 요소
    -   사용자 인터페이스
    -   프로그램 실행
    -   입출력 연산
    -   파일 시스템 조작
    -   통신
    -   오류 탐지
-   시스템 자체 동작을 보조하기 위한 요소
    -   자원 할당
    -   회계
        -   사용자가 어떤 종류의 컴퓨터 자원을 얼마나 사용하는지 관리
        -   시스템 사용 경험의 질을 높일 수 있는 데이터 자원이 된다.
    -   보호

## 2. 사용자 운영체제 인터페이스

### Command-Interpreter

-   shell이라고 불린다.

    -   이는 사용자가 처음 로그온할 때 실행되는 특수한 프로그램이다.
    -   리눅스에서 사용하는 Bash와 같은 것들이다.

-   구현 방법이 크게 두가지가 있다.
    -   Command-Interpreter 프로그램 코드 안에 명령에 대한 동작을 정의하는 방법
        -   확장하기 위해서는 shell 프로그램을 매번 수정해야 하고,
        -   shell 프로그램 자체너 너무 커진다.
    -   Command-Interpreter 프로그램은 그저 실행시킬 실행파일을 파악하는 작업만 진행
        -   Command-Interpreter프로그램이 실행파일을 실행시키고 적절한 파라미터를 넘기면 그 실행파일이 사용자가 원하는 동작을 수행
        -   예를 들어 mkdir 이라는 새로운 디렉토리를 만드는 실행 파일이 있고, 사용자는 이 실행파일을 통해 temp라는 디렉토리를 만들고 싶다고 생각하자
            ```yml
            $ mkdir temp # shell에서는 mkdir이라는 프로그램을 실행시키고 인자로 temp라고 하는 문자열을 넘긴다.
            # 여기서 $는 Bash shell을 사용하고 있다는 의미다.
            ```
        -   위의 작업을 통해 Command-Interpreter는 자신의 프로그램안에 동작을 정의할 필요가 없이 실행 파일을 찾는 작업만 해주면 되게 되었다.
        -   이렇게 하면 shell의 크기가 작아지고, 충분히 확장성을 갖출 수 있게된다.

### Graphical User Interface

-   생략

## 3. System Calls

### API(Application Programming Interface)

-   각 함수에 전달되어야 할 매개변수들과 프로그래머가 기대할 수 있는 반환 값을 포함한 응용 프로그래머가 사용 가능한 함수의 집합
-   API를 구성하는 함수들은 통상 응용 프로그래머를 대신해서 실제 System call을 호출한다.
-   사용자가 이렇게 호출할 수 있도록 대부분의 호출은 일반으로 C와 C++ 언어로 작성되어 있다.

### 사용자가 직접 System call을 사용하지 않고 API를 통하는지?

-   예를 들어 printf()라는 함수를 사용한다고 생각하자.
-   사용자는 화면에 문자열을 출력할 때, Window에서나, Mac OS, Linux에서도 동일하게 printf()함수를 사용한다.
-   하지만 곰곰히 생각해보면 문자열을 화면에 출력하기 위해서 각 OS가 사용하는 System call의 모양은 절대 같을리가 없다.
-   하지만 API설계자는 printf()라는 함수로 문자열 출력이라는 task를 추상화하고, OS에 따라서 문자열을 화면에 출력하기 위해서 필요한 형태의 System call을 알아서 부르도록 작성해두면 사용자는 어떤 OS에서 프로그래밍을 하더라도 printf()라는 함수를 사용해서 문자열을 화면에 출력할 수 있게된다.
-   게다가 System call을 직접 사용하는 것은 그 자체로 상당히 비용이 들어가는 작업이다.
-   그래서 우리는 API를 지원하게 되고, 사용자는 좀 더 유연성을 가지고 프로그래밍을 할 수 있게 된다.
-   하지만 안타깝게도 모든 API가 이런 기능을 지원하는 것은 아니다. 일부 라이브러리는 특정 OS에서만 동작하는 경우도 있다.
-   그렇기에 모든 OS를 지원하는 프로그래밍을 하기 위해서는 이러한 부분을 잘 고려할 필요가 있다.

### Syscall 이 동작하는 방식과, User mode와 kernel모드를 나누어 줄 수 있는 이유는 아래의 링크에서 최대한 열심히 설명해두었다.

-   궁금한 것이 있으면 꼭 댓글 바란다.
-   참고: [운영체제(1) - 운영체제란?(2) - 5. OS동작](https://cmpark0126.github.io/operating_system/OS_1-2/#5-os-%EB%8F%99%EC%9E%91)

### User program이 Syscall에게 매개변수를 넘기는 방식

-   위의 참고 링크에서도 설명하듯이 Syscall은 인터럽트로 동작하기에 기존 프로그램의 스트림에서 벗어나서 동작하고 결과값만 반환하는 식으로 되어있다.
-   이 때, 함수를 사용할 때 매개변수를 넘기듯이, Syscall에 매개변수를 넘겨야 하는 경우가 있는데 이 방법에는 두가지가 있다.
    -   CPU 레지스터 중 매개변수용으로 사용하는 $a0 ~ $a3에 매개변수를 기록해서 넘기는 경우
    -   매개변수의 개수가 4개를 넘어가는 경우는 stack을 사용 -> 주로 많은 운영체제는 매개변수 개수에 제한을 받지 않는 스텍 방법을 선호한다.
-   아래의 참고링크에서는 프로시저의 관점에서 이 방식이 어떻게 동작하는지 보여준다.
-   참고: [컴퓨터구조(2) - 명령어: 컴퓨터 언어(1) - 하드웨어의 프로시저 지원](https://cmpark0126.github.io/computer_architecture/CA_2-1/#%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4%EC%9D%98-%ED%94%84%EB%A1%9C%EC%8B%9C%EC%A0%80-%EC%A7%80%EC%9B%90)

## 4. System call의 유형

### 생략 (추후 업데이트)
