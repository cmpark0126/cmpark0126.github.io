---
title:  "운영체제(9) - Virtual Memory(2)"
modified: 2019-05-14T12:00:00-:30:00
categories:
  - Operating_System
tags:
  - [CS, Operating_System]
---

'운영체제'를 공부하여 정리한 내용입니다.

## 4. Page Replacement

### 접근법

-   위에서 page fault trap이 발생하면, 디스크에서 page를 찾아서 메모리의 **free frame(빈 프레임)** 에 넣어주어야 한다고 언급했다.

    -   그렇다면 free frame이 없다면 어떻게 해야할까?

-   두 가지 접근이 있다.
    1.  페이징을 요청한 프로세스를 종료시킨다.
        -   이는 좋은 접근이 아니다.
        -   우리가 virtual memory를 구현한 이유는 한정된 물리 메모리 자원에서 많은 프로세스를 지원하기 위한 것이었고,
        -   사용자는 Logical memory에만 신경쓰고 이런 물리적인 paging에 대한 부분을 절대 신경쓰지 않을 수 있도록 해주어야 하기 때문이다.
        -   이 신경을 쓰지 않는다는 의미, 혹은 User로 부터 hiding한다고 표현하는 이 의미는 User가 이 시스템의 구체적인 Spec을 몰라도 인터페이스의 정의로 원하는 목적을 달성할 수 있도록 해주어야 한다는 의미이다.
        -   그렇기에 이 방법은 쓰지 않는것이 좋다.
    -   현재 쓰지 않을 확률이 높은 페이지를 swap-out 시킨다.
        -   이렇게 하면 일단 multiprogramming을 끌고 갈 수 있다.
        -   이 선택은 앞의 선택에 비해서 좀 더 본래의 목적을 잃지않고 동작하게 할 수 있다.

### 주의

-   기본적으로 pager가 page를 swap-out 시키는 작업이 있다는 것은, 디스크에 두 번 접근한다는 의미이다.
    1.  Free frame을 만들기 위해 기존에 존재하는 page를 디스크로 옮기는 과정
    2.  만들어진 Free frame으로 적재할 page를 올릴 때.
-   하지만, 만약에 free frame을 만들기 위해서 swap out 시킬 page의 내용이 본래 디스크에 저장된 내용과 차이가 없다면, 디스크로 옮기지 않고 그저 frame에서 지우는 작업 만으로 swap out과 같은 효과를 낼 수 있다.
    -   이러한 상황을 하드웨어적으로 서포트하기 위해서 우리는 modify bit라는 것을 두고 page가 메모리에 적재된 이후 수정된 적이 있는지 없는지 확인할 수 있도록 한다.
        -   modify bit == 0: 메인 메모리에서 Swap out하기로 한 페이지의 내용이 수정된적이 없다는 의미로 보조 기억장치에 있는 내용과 메모리에 올라가 있는 내용에는 차이가 없다. 따라서 그냥 메인 메모리에서 내용을 지우기만 하면 된다.
        -   modify bit == 1: 메인 메모리에서 Swap out하기로 한 페이지의 내용을 보조 기억장치에 Backup해 두어야 한다.

### 해결해야 하는 문제

-   Frame Allocation Algorithm
    -   동작시켜야 하는 여러 프로세스가 존재하는 경우, 각 프로세스에는 얼마나 많은 프레임을 할당해야 할지 결정해야 한다.
-   Page Replacement Algorithm

    -   페이지 교체가 필요할 때마다 어떤 페이지를 교체해야 할지 결정해야 한다.
    -   단순히 생각해보면 앞으로 더이상 필요없을 가능성이 높은 페이지를 교체하는 것이 경제적이다.
    -   Swap out된 페이지가 다시 필요해지면 다시 메모리로 올리는데에 비용이 드니까 말이다.

-   이 두 알고리즘을 개선시키기만 해도 전체적인 Demanding Paging 시스템의 퍼포먼스를 크게 올리는 것이 가능하다.

## Page Replacement Algorithm

-   우선 상황을 분석하는 방법을 알아보자.

    -   프로세스가 참조하는 주소열이 다음과 같다고 생각하자.
            0100 0432 0101 0612 0102 0103 0104 0101 0611 0102 0103
            0104 0101 0610 0102 0103 0104 0101 0609 0102 0105
    -   page offset이 100 byte를 표현한다면, 즉, page의 크기가 100byte라면, 이 열은 다음과 같은 순서로 page를 참조한다는 것을 알 수 있다.
            1 4 1 6 1 1 1 1 6 1 1
            1 1 6 1 1 1 1 6 1 1
            (위의 값을 100단위로 나누면 된다)
    -   이 때, page를 연속으로 참조하는 경우를 압축하여 표현하면 다음과 같은 순서로 Page를 참조한다는 것을 알 수 있다.  
            1 4 1 6 1 6 1 6 1 6 1 (최종 page 참조 리스트)


-   우리가 가진 메인 메모리가 3개 이상의 frame을 가지고 있다.

    -   이 경우, 1, 4, 6 page가 pager를 통해 메인 메모리로 swap in이 될 때, 항상 free frame이 존재할 것이다.
    -   이 때는 각 페이지를 최초로 reference 하는 경우 한번씩, 총 3번의 page fault만 일어난다. (총 3개의 page 접근)

-   우리가 가진 메인 메모리가 1개의 frame을 가지고 있다.
    -   이 경우는 최초 page 참조를 포함해서, 이전과 다른 page에 접근할 때는 무조건 page fault가 일어난다.
    -   그래서 총 11번의 page fault가 일어난다. (바로 위에서 최종적로 정리한 page 참조 리스트 참고)
