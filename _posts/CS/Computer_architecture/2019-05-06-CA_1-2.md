---
title:  "컴퓨터구조(1) - 컴퓨터 추상화 및 관련 기술(2)"
modified: 2019-05-06T14:00:00-:30:00
categories:
  - Computer_architecture
tags:
  - [CS, Computer_architecture]
---

한티미디어의 '컴퓨터 구조 및 설계'를 공부하여 정리한 내용입니다.

## 케이스를 열고
1. 하드웨어가 하는 일
 - 데이터 입출력
 - 데이터 처리
 - 데이터 저장

1. <u><b>컴퓨터의 고전적 구성 요소 (외울것)<b/><u/>
 - 입력
 - 출력
 - 메모리
 - 데이터패스 (datapath)
 - 제어 (control)
 - 이 중, 마지막 두 개는 합쳐서 프로세서라고 부르기도 한다.

1. 집적회로 또는 칩
 - 여러 독립된 요소를 집적해서 하나의 칩으로 만든 것
 - 각각의 트랜지스터 칩 사용
 - ex) CPU 코어, 메인 메모리 등의 부품들을 집적한다

1. 마이크로 프로세서에 포함된 것
 - 데이터패스, 제어 유닛의 두 부분으로 구성
 - 데이터패스: 산술 연산 수행
 - 제어: 명령어가 뜻하는 바에 따라 데이터패스, 메모리, 입출력장치 제어

1. 메모리 (계층적 구조에 따라)
 - SRAM - 캐시: DRAM의 버퍼 역할
 - DRAM - 메인 메모리: 프로그램의 명령어와 프로그램 실행중 필요한 데이터 기억에 사용
 - 보조기억장치 - 디스크 등: 속도가 느리지만, 보통 용량이 상대적으로 큼

1. <b>명령어 집합 구조 (추상화를 가능하게 만들었다)<b/>
 - <b>하드웨어와 최하위 소프트웨어 간의 인터페이스<b/>
 - 이진 기계어 프로그램 작성을 위해 알아야 하는 모든 정보를 말한다.
 - 이는 반대로, 프로그램 작성에 있어서 너무 세세한 부분은 감추어져 있다는 의미이기도 하다. (운영체제 레벨 등에서)
 - <b>응용 프로그래머에게 제공되는 기본 명령어 집합(일반적으로 어셈블리 언어 레벨)과 운영체제 인터페이스를 합쳐서 ABI라고 한다.<b/>
 - 이를 통해 프로그래머는 프로그램을 작성할 때 하드웨어와 독립적으로 컴퓨터의 기능을 생각하여 프로그램을 작성할 수 있게 된다.
 - (비슷한 것으로는 API가 있다. 이는 소스코드 레벨에서 생각하면 된다.)

1. 데이터의 안전한 저장소
 - 휘발성 메모리 - 메인 메모리: 전원이 끊기면 기억이 지워진다.
 - 비휘발성 메모리 - 보조기억장치: 전원이 끊겨도 기억이 남아있다. 다만, 너무 많이 소비하면 더 이상 쓸 수 없는 내구도 개념이 존재한다.

1. 컴퓨터 간의 통신
 - (생략)

## 프로세서와 메모리 생산 기술
1. 트랜지스터
 - 실리콘에 특수한 화학적 처리를 거쳐, 불순불을 첨가하면 조건에 따라 도체가 되기도 하고 절연체가 되기도 한다.
 - 그렇게 전기로 제어되는 On/Off 스위치가 된다.
 - 집적회로는 수십, 수백개의 트랜지스터를 칩 하나에 집적시킨 것

## 성능
1. 성능 측정이 어려운 이유
 - 성능을 측정하기 위한 기준이 다양
 - ex) 응답시간(개인의 관심사), 처리량(데이터 센터의 관심사) (사실 이 두 요소는 상호보완적이다. 그냥 여러개가 존재한다는 하나의 예시로 받아들이면 좋겠다)

1. 성능의 측정
 - 시간은 컴퓨터 성능의 가장 기본적인 척도
 - CPU 시간: 특정 작업의 실행을 위해 CPU가 소비한 실제 시간 - 이는 사용자가 느끼는 시간과 다르다. 사용자가 작업에 느끼는 시간은 경과 시간에 해당한다. 실제로는 CPU가 그 프로그램만을 위해서 움직이는 것이 아니라 동시에 다른 작업을 담당하기도 하기 때문이다.
 - 컴퓨터는 하드웨어 이벤트가 발생하는 시점을 클럭을 이용하여 결정한다.
 - Clock cycle(클럭 사이클): 클럭과 클럭 사이의 시간 간격
 - Clock period(클럭 주기): 각 클럭 사이클의 시간 길이, ex) 250ps
 - Clock rate(클럭 속도): 1초당 클럭이 진동하는 횟수, ex) 4GHz := 1/250ps, cf) cycle/sec (초당 사이클 개수)

1. 명령어 성능
 - CPU 클럭 사이클 수 = 명령어 수 X 명령어당 평균 클럭 사이클 수(clock cycles per instruction)
 - 이 때, 명령어당 클럭 사이클 수는 줄여서 CPI라고 부른다.

1. 고정적인 CPU 성능식
 - CPU 시간 = (명령어 수 X CPI) / 클럭 속도(초당 사이클 개수)
 - 명령어 유형별로 CPI를 따로 두고 성능을 계산 하는 것도 가능하다. (아래 표 참고)

|유형|A|B|
|:---:|:---:|:---:|
|`개수`|`3`|`4`|
|`CPI`|`1`|`2`|

`CPU 클럭 사이클 수 = (3 \* 1) + (4 \* 2)`  

- 기존 CPU 시간: [15 = (I \* CPI) / clock rate],
 - 명령어 개수(I) -> 0.6배, CPI -> 1.1배 로 수정되었을 때,
 - CPU 시간은?
 - 15 \* 0.6 \* 1.1 = ((I \* 0.6) \* (CPI \* 1.1)) / clock rate
