---
title:  "컴퓨터구조(3) - 컴퓨터 연산(1)"
modified: 2019-05-10T12:00:00-:30:00
categories:
  - Computer_architecture
tags:
  - [CS, Computer_architecture]
---

'컴퓨터 구조 및 설계'를 공부하여 정리한 내용입니다.

## 서론
1. 이 장에서 배울 것
 - 소수나 실수는 이진수로 어떻게 표현할까?
 - 컴퓨터로 표현할 수 있는 수보다 더 큰 숫자가 나오면 어떻게 처리해야 하나?
 - 하드웨어는 곱셈과 나눗셈을 어떻게 수행할까?

**생각해보면 쉽지 않은 문제들이다. 궁금증을 가지고 내용을 살펴보면 컴퓨터로 연산하는 방식을 생각해낸 사람들의 지혜를 좀 더 온전히 느낄 수 있지 않을까?**

## 덧셈과 뺄셈
1. 같이 생각해보자
 - 연산을 진행할 숫자가 A, B가 있다고 생각하자
 - 우선 두 숫자는 컴퓨터가 표현할 수 있는 숫자이다. (int를 사용한다고 했을 때 32bit로 표현이 가능한 숫자)

1. 덧셈
 - A+B 연산을 진행한다고 하면, A와 B가 모두 양수일 경우나 음수일 경우는 표현할 수 있는 범위를 넘어갈 가능성이 생긴다. 이렇게 되었을 때, 우리는 오버플로(Overflow)가 일어났다고 표현한다.
 - A+B 연산을 진행할 때, A, B가 서로 다른 부호를 가지고 있을 경우에는 컴퓨터가 표현할 수 있는 범위를 넘어갈 가능성이 없다. 이 때는 오버플로가 절대 발생하지 않는다.

1. 뺄셈
 - A-B 연산을 진행할 때는 반대로 서로 다른 부호를 가지고 있을 때 컴퓨터가 표현할 수 있는 범위를 넘어갈 가능성이 있다. 예를 들어 A는 양수, B는 음수라고 생각하자. 이 때 우리는 B를 양수 C를 사용해서 B = (-C)로 표현하는 것이 가능하다. 그러면 A-B = A - (-C) = A + C 가 되기 때문에 위에서 보았던 덧셈 연산에서 오버플로가 발생할 가능성이 있는 경우와 같은 형태를 가진다는 것을 알 수 있다.
 - A-B 연산을 진행할 때, 같은 방식으로 우리는 A와 B가 서로 같은 부호를 가지고 있을 때 오버플로가 발생하지 않는다는 것을 알 수 있다.

1. MIPS는 오버플로를 어떻게 처리하나?
 - 부호가 있는 연산의 경우는 오버플로가 발생하면 예외(Exception)를 발생시킨다.
 - 부호가 없는 연산(addu 등)의 경우는 오버플로가 발생해도 예외를 발생시키지 않는다.
 - 가끔은 포화(saturating) 연산을 사용한다. 이 연산은 주로 신호 처리나 미디어에서 많이 사용하는 연산으로, 오버플로가 발생하는 연산은 컴퓨터가 표현할 수 있는 가장 큰(혹은 작은) 숫자로 포화시키고 오버플로가 일어나는 현상이 있었다는 것을 기록하면서 다음 연산을 정상적으로 진행시키는 방식이다.

1. 부호있는 덧셈 연산 오버플로 검사 방법
 - 피연산자 두 개는 A, B라고 하고 연산 결과는 R(esult)이라고 하자.
 - A와 B를 xor연산한다.
 - 위 xor연산의 결과가 C라고 했을 때, C의 MSB가 1이면 A와 B의 부호는 서로 반대라는 의미이고 이 때는 오버플로가 절대 일어나지 않는다는 것을 위에서 논의했다.
 - C의 MSB가 0이면 A와 B의 부호가 서로 같다는 의미이고, 이때는 오버플로가 있을 가능성이 있기에 다음 검사를 시작한다.
 - R과 A를 xor연산한다.
 - 이 xor연산의 결과가 D라고 하자. D의 MSB가 0이면 A와 C의 부호가 같다는 의미이고 이 경우는 오버플로가 일어나지 않았다는 것을 의미한다. (오버플로가 일어나면 A와 C의 부호가 반대가 된다. 직접 해보자.)
 - 반대로 D의 MSB가 1이면 A와 C의 부호가 서로 다르다는 의미이고, 이는 오버플로가 일어났다는 의미로 받아들이는 것으로 받아들일 수 있다.

1. 부호없는 덧셈 연산 오버플로 검사 방법
 - 피연산자 두 개는 A, B라고 하고 연산 결과는 R(esult)이라고 하자.
 - A에 있는 bit를 모두 반전시킨다. 그리고 이를 A'라고 하자 (if A = 0100_1000 -> A' = 1011_0111) (이 경우는 현재 8bit로 표현했지만, int의 경우는 32bit이다.)
 - A'와 B를 비교했을 때, A'가 B보다 작으면 A와 B를 더하면 오버플로가 일어난다는 것을 알 수 있다.
 - 왜냐면, 위의 예시에 따라 A + A' = 1111_1111이 되듯이, 컴퓨터로 표현할 수 있는 최댓값이 된다. 이 때, B가 A'보다 클 경우에 A + B를 하면 컴퓨터로 표현할 수 있는 최댓값을 넘어간다는 것을 알 수 있다. 이는 오버플로가 일어난다는 것을 의미한다. (현재의 연산은 부호없는 연산이라는 것을 잊지 말자)


## 곱셈
+ 용어 정리
    - A \* B = C
    - Multiplicand: A
    - Multiplier: B
    - Product: C

+ 곱셈 알고리즘 하드웨어의 순차적 버전
    - (추후 업데이트)

+ 곱셈 알고리즘 하드웨어의 수정된 버전
    - 2 \* 3 = 6 -> 0010 \* 0011 = 0110
    - Multiplicand: 0010, Multiplier: 0011, Product: 0110
    - <표2>에서 순차적으로 보여주고 있다.

+ 추가 내용
    - 부호있는 곱셈의 경우는 Multiplicand와 Multiplier의 부호만 따로 빼서 기억하고 둘 모두 부호 없는 버전으로 만들고 연산 이후에 부호를 추가하면 된다.
    - 더 빠른 곱셈을 하기 위해서는 이 loop를 병렬로 진행하면 된다. 물론 간단히 되는 것은 아니고 각 자리에서의 연산에서 생기는 carry out 등을 고려해야 하지 그래도 만 더 빨리 하는 것이 가능하다.



 |step|Multiplicand|Multiplier|Product(이전) + Multiplicand or 0|Product(결과)|
 |:---:|:---:|:---:|:---:|:---:|
 |1|001(1)|0000_0010|0000_0000 + 0000_0010<br>(because Multiplicand's LSB is 1)|0000_0010|
 |2|000(1)<br>(shift right)|0000_0100<br>(shift left)|0000_0010 + 0000_0100<br>(because Multiplicand's LSB is 1)|0000_0110|
 |3|000(0)<br>(shift right)|0000_1000<br>(shift left)|0000_0110 + 0000_0000<br>(because Multiplicand's LSB is 0)|0000_0110|
 |4|000(0)<br>(shift right)|0001_0000<br>(shift left)|0000_0110 + 0000_0000<br>(because Multiplicand's LSB is 0)|0000_0110|
<표2>
