---
title:  "컴퓨터구조(3) - 컴퓨터 연산(1)"
modified: 2019-05-10T12:00:00-:30:00
categories:
  - Computer_architecture
tags:
  - [CS, Computer_architecture]
---

'컴퓨터 구조 및 설계'를 공부하여 정리한 내용입니다.

## 1. 서론

##### 이 장에서 배울 것

-   소수나 실수는 이진수로 어떻게 표현할까?
-   컴퓨터로 표현할 수 있는 수보다 더 큰 숫자가 나오면 어떻게 처리해야 하나?
-   하드웨어는 곱셈과 나눗셈을 어떻게 수행할까?

*생각해보면 쉽지 않은 문제들이다. 궁금증을 가지고 내용을 살펴보면 컴퓨터로 연산하는 방식을 생각해낸 사람들의 지혜를 좀 더 온전히 느낄 수 있지 않을까?*

## 2. 덧셈과 뺄셈

##### 같이 생각해보자

-   연산을 진행할 숫자가 A, B가 있다고 생각하자
-   우선 두 숫자는 컴퓨터가 표현할 수 있는 숫자이다. (int를 사용한다고 했을 때 32bit로 표현이 가능한 숫자)

##### 덧셈

-   A+B 연산을 진행한다고 하면, A와 B가 모두 양수일 경우나 음수일 경우는 표현할 수 있는 범위를 넘어갈 가능성이 생긴다. 이렇게 되었을 때, 우리는 오버플로(Overflow)가 일어났다고 표현한다.
-   A+B 연산을 진행할 때, A, B가 서로 다른 부호를 가지고 있을 경우에는 컴퓨터가 표현할 수 있는 범위를 넘어갈 가능성이 없다. 이 때는 오버플로가 절대 발생하지 않는다.

##### 뺄셈

-   A-B 연산을 진행할 때는 반대로 서로 다른 부호를 가지고 있을 때 컴퓨터가 표현할 수 있는 범위를 넘어갈 가능성이 있다. 예를 들어 A는 양수, B는 음수라고 생각하자. 이 때 우리는 B를 양수 C를 사용해서 B = (-C)로 표현하는 것이 가능하다. 그러면 A-B = A - (-C) = A + C 가 되기 때문에 위에서 보았던 덧셈 연산에서 오버플로가 발생할 가능성이 있는 경우와 같은 형태를 가진다는 것을 알 수 있다.
-   A-B 연산을 진행할 때, 같은 방식으로 우리는 A와 B가 서로 같은 부호를 가지고 있을 때 오버플로가 발생하지 않는다는 것을 알 수 있다.

##### MIPS는 오버플로를 어떻게 처리하나?

-   부호가 있는 연산의 경우는 오버플로가 발생하면 예외(Exception)를 발생시킨다.
-   부호가 없는 연산(addu 등)의 경우는 오버플로가 발생해도 예외를 발생시키지 않는다.
-   가끔은 포화(saturating) 연산을 사용한다. 이 연산은 주로 신호 처리나 미디어에서 많이 사용하는 연산으로, 오버플로가 발생하는 연산은 컴퓨터가 표현할 수 있는 가장 큰(혹은 작은) 숫자로 포화시키고 오버플로가 일어나는 현상이 있었다는 것을 기록하면서 다음 연산을 정상적으로 진행시키는 방식이다.

##### 부호있는 덧셈 연산 오버플로 검사 방법

-   피연산자 두 개는 A, B라고 하고 연산 결과는 R(esult)이라고 하자.
-   A와 B를 xor연산한다.
-   위 xor연산의 결과가 C라고 했을 때, C의 MSB가 1이면 A와 B의 부호는 서로 반대라는 의미이고 이 때는 오버플로가 절대 일어나지 않는다는 것을 위에서 논의했다.
-   C의 MSB가 0이면 A와 B의 부호가 서로 같다는 의미이고, 이때는 오버플로가 있을 가능성이 있기에 다음 검사를 시작한다.
-   R과 A를 xor연산한다.
-   이 xor연산의 결과가 D라고 하자. D의 MSB가 0이면 A와 C의 부호가 같다는 의미이고 이 경우는 오버플로가 일어나지 않았다는 것을 의미한다. (오버플로가 일어나면 A와 C의 부호가 반대가 된다. 직접 해보자.)
-   반대로 D의 MSB가 1이면 A와 C의 부호가 서로 다르다는 의미이고, 이는 오버플로가 일어났다는 의미로 받아들이는 것으로 받아들일 수 있다.

##### 부호없는 덧셈 연산 오버플로 검사 방법

-   피연산자 두 개는 A, B라고 하고 연산 결과는 R(esult)이라고 하자.
-   A에 있는 bit를 모두 반전시킨다. 그리고 이를 A'라고 하자 (if A = 0100_1000 -> A' = 1011_0111) (이 경우는 현재 8bit로 표현했지만, int의 경우는 32bit이다.)
-   A'와 B를 비교했을 때, A'가 B보다 작으면 A와 B를 더하면 오버플로가 일어난다는 것을 알 수 있다.
-   왜냐면, 위의 예시에 따라 A + A' = 1111_1111이 되듯이, 컴퓨터로 표현할 수 있는 최댓값이 된다. 이 때, B가 A'보다 클 경우에 A + B를 하면 컴퓨터로 표현할 수 있는 최댓값을 넘어간다는 것을 알 수 있다. 이는 오버플로가 일어난다는 것을 의미한다. (현재의 연산은 부호없는 연산이라는 것을 잊지 말자)
