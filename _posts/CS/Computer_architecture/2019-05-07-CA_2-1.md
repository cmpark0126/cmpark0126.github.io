---
title:  "컴퓨터구조(2) - 명령어: 컴퓨터 언어(1)"
modified: 2019-05-07T14:00:00-:30:00
categories:
  - Computer_architecture
tags:
  - [CS, Computer_architecture]
---

'컴퓨터 구조 및 설계'를 공부하여 정리한 내용입니다.

## 서론
1. 기본 원리
 - 하드웨어가 제공하는 기본적인 연산은 몇 가지 안 된다.
 - 컴퓨터 제작 및 설계자들에게는 `하드웨어와 컴파일러 제작이 쉽고`, 최소 비용에서 최대 성능을 구현할 수 있는 언어를 찾아내고자 하는 공통의 목표가 있다.

1. 앞으로 배울 내용
 - 명령어 집합의 하드웨어 표현 방식 및 상위 수준 언어와의 관계
 - 내장 프로그램 개념: 여러 종류의 데이터와 명령어를 메모리에 숫자로 저장할 수 있다는 개념

## 하드웨어 설계
1. 설계 원칙
 - 간단하게 하기 위해서는 규칙적인 것이 좋다: 하나의 처리 방법으로 여러개의 명령어를 처리할 수 있다.
 - 작은 것이 더 빠르다: 레지스터의 개수가 많으면 전기 신호가 더 멀리까지 전달되어야 해서 클럭 사이클 시간이 길어진다. (레지스터 to 레지스터)
 - 좋은 설계에는 적당한 절충이 필요하다: 모든 명령어의 길이를 같게 하고 싶은 생각과 모든 명령어 포맷을 하나로 통일하고 싶은 생각에서 적당히 절충안을 생각해 낼 필요가 있다.

1. 부호있는 수와 부호없는 수
 - 이진 자리수(binary digit): 비트(bit)
 - LSB와 MSB

1. 부호를 사용할 때 표현 방식
 - MSB를 sign bit로 사용
 - 모든 자리의 bit를 반전시키고 1bit를 더하면 보수가 된다.
 - 16bit to 32 bit 부호 확장 방식: 16bit 정보의 MSB를 복사해서 32bit의 상위 16bit를 채우고, 나머지 하위 16bit는 기존 데이터를 그대로 넣는다.


##  명령어의 컴퓨터 내부 표현
1. 설계의 절충안
 - 위의 설계원칙에서도 말했듯이 좋은 설계에는 적당한 절충이 필요하다
 - MIPS는 명령어의 길이를 같게 하고, 명령어 종류에 따라 형식을 다르게 하는 것으로 했다. (R, I, jump, etc.): 내부에서는 이를 OPCODE라는 필드를 사용하여 파악한다.

1. MIPS 명령어의 필드
 - 아래 표 참고
 - 아래 명령어 포맷으로 구체적인 명령어들이 어떻게 구현되어 있는지에 대한 내용은 생략하겠다.
 - MIPS 명령어를 사용하여 CPU가 구동되는 것을 간단하게 시뮬레이션 할 수 있는 코드를 구현해 두었다. (명령어는 10개 정도 지원)
 - [Implementation of 32bits MIPS using Verilog](https://github.com/cmpark0126/MIPS_32bits)
 - [코드 설명 자료](https://github.com/cmpark0126/MIPS_32bits/blob/master/TeamI_21400337_%EB%B0%95%EC%B2%9C%EB%AA%85_21400404_%EC%8B%A0%EB%8B%A4%ED%98%84.pdf)

 |opcode|rs|rt|rd|shift_amount|function|
 |:---:|:---:|:---:|:---:|:---:|:---:|
 |6bit|5bit|5bit|5bit|5bit|6bit|
 |명령어가 실행할 연산을 구분하는데 사용 (R, I, jump)|피연산자1|피연산자2|연산 결과 저장 레지스터: (register for destination)|비트 자리이동용으로 사용|기능 코드: 구분된 연산에서 구체적인 기능을 지정, <br>EX) opcode로 Rtype인 것을 알았다면 구체적으로 Add를 할지, Sub를 할지 정하는 코드|

## 하드웨어의 프로시저 지원
1. 프로시저(callee)를 실행할 때 작업하는 단계 (순서대로)
 - 프로시저가 접근할 수 있는 곳에 인수를 넣는다: $a0 ~ $a3
 - 프로시저로 제어를 넘긴다: jal procedureAddress(동시에 $ra에는 PC+4가 저장됨: Caller로 돌아가기 위해서)
 - 프로시저가 필요로 하는 메모리 자원, 레지스터 자원을 획득한다: stack에 Caller에서 사용하던 자원(레지스터에 저장되어 있던 값)을 임시 저장한다.
 - 필요한 작업을 수행한다
 - 호출한 프로그램(caller)이 접근할 수 있는 장소에 결과 값을 넣는다: $v0 ~ $v1
 - 프로시저는 프로그램 내의 여러 곳에서 호출될 수 있으므로 원래 위치로 제어를 돌려준다: jr $ra, stack에 임시 저장해 두었던 자원을 다시 돌려받는다.

1. Stack에 값을 후퇴시켜두는 작업: 레지스터 스필링
 - 모든 레지스터 값을 후퇴시키는 것은 너무 많은 낭비를 부를 수 있다.
 - 따라서, 스필링을 할 레지스터를 관례적으로 정하자
 - 그렇게 정해진 것이 $s0~$s7, stack에는 이 레지스터들의 값만 후퇴시킨다.
 - 반대로 $t0~$t9의 경우는 피호출 프로그램이 값을 보존해주지 않도록 한다.
 - 스필링 시킬 레지스터의 값이 현저히 줄어든다.

1. 프로시저 안에서 프로시저를 부르는 경우
 - $ra에 저장되는 값이 중첩되는 가능성이 생긴다.
 - 그렇기에 이 $ra의 값도, 이러한 상황일 때는 stack에 스필링하여 문제를 해결한다.
